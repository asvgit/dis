\section{Реализация программного решения}

	Для реализации поставленной цели была необходимость в решении двух задач:
		\begin{itemize}
			\item[--] реализация среды, в которой должна происходить работа системы управления;
			\item[--] реализация системы, которая должна посредством доказательства теоремы выполнять
				управление группой лифтов, тем самым обслуживая поступаемые в течении времени запросы.
		\end{itemize}

	Выполнение обоих задач на языке высокого уровня было бы не корректно,
		так как подобные языки не являются декларативными,
		что делает наделение системы управления интеллектуальностью значительно усложняет задачу.
		Но и реализация среды на языке Prolog является не совсем удачно идеей,
		так как это увеличит количество потребляемых ресурсов.
		Однако реализовывать эти задачи на разных языках, а потом настроить совместную работу тих решений,
		является непростой задачей, которая займёт достаточно много времени.
		Поэтому было принято решение обе задачи реализовать на языке Prolog, так как основной
		целью работы является разработка интеллектуальной системы управления.
		Более того, правила для описания среди можно использовать в построении логического вывода.

	В процессе работы поставленные задачи были решены разными способами:
		\begin{itemize}
			\item[--] реализация на языке Python;
			\item[--] реализация но языке Prolog.
		\end{itemize}
	
	Хоть и целесообразность использования языка Prolog понятна, реализация на Python будет необходима для сравнения
	обоих решений. А сам язык Python достаточно прост и обладает большим количеством решений для моделирования
	различных сред, в данном случае используемым решением является библиотека SimPy.

	\subsection{Описание реализации на SimPy}

		Данная реализация системы управления группой лифтов с ограниченным количеством кабин и несколькими людьми,
			которые приходят для попадания с одного этажа на другой.
			В данной системе используется ресурс для моделирования ограниченного количества кабин.
			Он также определяет процесс выбора кабины и перевозку ей человека.

		Когда человек появляется рядом с шахтой лифта, он вызывает первую из свободных кабин.
			Как только он его кабина забирает, время ожидания человека прекращается.
			Он, наконец, добирается до нужного этажа и уходит.

		После старта системы начинается генерация людей, они появляются после случайного интервала времени,
		пока продолжается симуляция.


		При том, что данная программа является многопоточной, стоит отметить тот факт, что здесь используются общие ресурсы.
			Эти ресурсы могут использоваться для ограничения количества процессов, использующих их одновременно.
			Процесс должен запрашивать право использования ресурса. Как только право на использование больше не требуется,
			оно должно быть выпущено. Данная система смоделирована как ресурс с ограниченным количеством кабин.
			Люди прибывают к кнопке вызова кабины и просят выполнить перевозку на другой этаж.
			Если все кабины заняты, человек должен ждать, пока один из пассажиров не закончит поездку и не освободит кабину.

		Данная реализация получилась достаточно простой, весь исполняемый скрипт поместился в один файл.
			Листинг того файла размещён в приложении А. Из листинга видно, как с помощью библиотеки SimPy
			было выполнено управление общими ресурсами (кабинами). Это выполнялось при помощи функции Resourse.
			Так же можно заметить как выполнялся запрос на резервирование общих ресурсов:
\begin{lstlisting}
with elev.cab.request() as request:
	yield request
	info('%s is moving' % (man.name), env)
	yield env.process(elev.moving(man))
\end{lstlisting}

		Таким образом было реализовано и ожидание ресурса, если тот на время появления запроса занят.

	\subsection{Ведение журнала о выполнении программы}
		Так как разрабатываемые реализации не обладают графическим интерфейсом, очень важно обратить внимание
			на разработку журнала программы. Посредством разработанных журналов можно детально изучить
			особенности выполнения программных решений и сделать выводы о корректности работы.

		Информация в журнале разделяется на следующие типы:
			\begin{itemize}
				\item[--] INFO -- некоторая информация о ходе выполнения или некоторые оповещения;
				\item[--] TRACE -- трассировка программы, позволяет отследить, через какие состояния прошла программа;
				\item[--] DEBUG -- подробная информация о протекающих процессах, данная информация достаточно объемная,
					поэтому подобная информация выводилась только при отладке программ;
				\item[--] WARNING -- важные предупреждения, которые помогают выявить критичные участки кода,
					которые могут вести к некорректной работе;
				\item[--] ERROR -- информация о критичных ошибках в выполнении программы. Эта информация помогает
					быстро исправлять ошибки в коде.
			\end{itemize}

		Так же реализована возможность задавать уровень ведения журнала, которая позволяет не захламлять журнал,
			если нет необходимости в подробной информации. Например, для иллюстрации журнала в отчётах
			отладочная информация не нужна, или для проведения тестов достаточно получать предупреждения
			и информацию о результатах проведения теста.

		В процессе разработки ведения журнала было выделено четыре уровня:
			\begin{itemize}
				\item[--] вывод только предупреждений и информации об ошибках;
				\item[--] предупреждения, ошибки и оповещения;
				\item[--] предупреждения, ошибки, оповещения и трассировка;
				\item[--] предупреждения, ошибки, оповещения, трассировка и отладочная информация;
			\end{itemize}

		Сама же запись в журнал имеет следующую структуру.
\begin{lstlisting}
23 May 2018 22:48:41 [40:4] TRACE Manage people
\end{lstlisting}
		Первые четыре столбца в журнале -- это реальное время журналирования момента модуляции.
		Следующим столбцом идёт связка двух чисел, первое число - это номер процесса,
		он необходим для идентификации сессии, а второе число показывает момент времени модуляции.
		А дальнейшая информация передаёт сообщения записываемые программой.

	\subsection{Пример работы реализации на SimPy}

		Данный пример иллюстрирует работу группы лифтов, где их количество равно 2, в здании с 30 этажами.
			В ходе работы системы появится люди в случайные моменты времени на случайных этажах этажах,
			и у каждого человека целью является добраться на другой этаж.

		Изначально первая кабина находится на первом этаже $e_0$, а вторя на втором $e_1$.
			Ниже приведён лог показывающий работу системы:

\begin{lstlisting}
19 May 2018 16:00:58 [51:null] Session end
23 May 2018 21:41:15 [23:null] Start session
23 May 2018 21:41:15 [23:0] Man 0 appears on floor '0', target '24'
23 May 2018 21:41:15 [23:0] Man 0 is moving
23 May 2018 21:41:15 [23:12] Man 1 appears on floor '14', target '5'
23 May 2018 21:41:15 [23:12] Man 1 is moving
23 May 2018 21:41:15 [23:24] Man 0 has reached by Cab 0
23 May 2018 21:41:15 [23:24] Man 2 appears on floor '2', target '10'
23 May 2018 21:41:15 [23:24] Man 2 is moving
23 May 2018 21:41:15 [23:33] Man 3 appears on floor '3', target '1'
23 May 2018 21:41:15 [23:34] Man 2 has reached by Cab 0
23 May 2018 21:41:15 [23:34] Man 3 is moving
23 May 2018 21:41:15 [23:35] Man 1 has reached by Cab 1
23 May 2018 21:41:15 [23:39] Man 3 has reached by Cab 0
23 May 2018 21:41:15 [23:null] Session end
9 May 2018 16:00:58 [51:null] Session end
\end{lstlisting}

			Изучив выше изложенный журнал, можно увидеть, что за время симуляции появилось 4 человека,
				каждый человек доставлен.

	\subsection{Реализация на языке Prolog}

		Перед реализацией системы, которая будет осуществлять управление посредством выполнения логического вывода
			необходимо реализовать среду, в которой будет протекать процесс, нуждающийся в автоматическом обслуживании.
			Аналогично реализации на языке Python была выполнена модель на языке Prolog с некоторыми различиями:
		\begin{itemize}
			\item[--] всё действие выполняется в один поток;
			\item[--] все случайные значения генерируются заранее.
		\end{itemize}

		Следует пояснить какие значения задаются случайным образом:
		\begin{itemize}
			\item[--] этаж, которого поступает запрос на обработку;
			\item[--] этаж, который будет выбран в качестве ли в процессе обработки запроса;
			\item[--] момент времени, в который поступает запрос.
		\end{itemize}

		Моделирование процесса происходит за счёт выполнения логического вывода, что облегчает наделять 
			систему автоматического управления интеллектуальностью. Более того, правила описанные для
			моделируемого процесса будут использованы для построения решения системой управления.

		В приложении А представлен основной файл, в котором реализована инициализация логического вывода.
			Данный код иллюстрирует реализацию формулы времени. Благодаря функционалу SWI-Prolog
			в дальнейшем предикаты отражающие время можно будет указывать в правилах только при необходимости.
		
		Реализации правил manage\_people и manage\_elevators вынесены в другие файлы,
			как как являются весьма громоздкими.
			Manage\_people отвечает за внешний фактор (случайное появление нуждающихся в лифте людей).
			А manage\_elevators включает в себя формулы движения лифтов.

		Что касается инициализации моделируемого процесса, то из журнала можно узнать все детали начального
			состояния модели.

\begin{lstlisting}
23 May 2018 22:48:41 [40:null] DEBUG Show var: Steps '20' Elev '2' Floors '5' People '2'
23 May 2018 22:48:41 [40:null] TRACE Start modulation
23 May 2018 22:48:41 [40:null] DEBUG Init people apprears '[2,4]'
23 May 2018 22:48:41 [40:null] DEBUG Init people floors '[1,0]'
23 May 2018 22:48:41 [40:null] DEBUG Init people targets '[4,4]'
23 May 2018 22:48:41 [40:null] DEBUG Init people waiting '[0,0]'
23 May 2018 22:48:41 [40:null] DEBUG Init people states '[0,0]'
23 May 2018 22:48:41 [40:null] DEBUG Init elevators floors '[0,1]'
\end{lstlisting}

	Из данной части журнала можно выяснить следующие вещи:
		\begin{itemize}
			\item[--] моделируемый процесс будет протекать в течении 20 единиц времени;
			\item[--] количество кабин равняется двум;
			\item[--] количество этажей равняется пяти;
			\item[--] количество поступаемых запросов равняется двум;
			\item[--] первый запрос появится во после истечения второй единицы времени,
				а второй после четвёртой;
			\item[--] запросы будут со второго и первого этажа соответственно;
			\item[--] целью обоих запросов является этаж под номером 4;
			\item[--] кабины расположены на первом и втором этажах.
		\end{itemize}

	Во время инициализации моделируемого процесса нет информации о текущей единице времени, поэтому пишется null.

	За время выполнения моделируемого процесса будет в журнале будет саккумулирована вся промежуточная информация.
		Это позволяет более ясно представить картину о произошедших действиях. Особенно такой функционал важен
		при отладке программного решения, так как в момент внеплановой остановки программы информации предоставляемой
		инструментарием SWI-Prolog  может не хватать. Тем более программа может вести себя некорректно
		и без внезапных остановок.

	После завершения моделируемого процесса необходимо собрать данные о результатах, которые необходимы для оценки разработанного программного решения.

	Разработанное ведение журнала позволяет записывать различную информацию о принципах проходимого процесса.
\begin{lstlisting}
23 May 2018 22:48:41 [40:18] TRACE Start step
23 May 2018 22:48:41 [40:18] TRACE Finish step
23 May 2018 22:48:41 [40:19] TRACE Start step
23 May 2018 22:48:41 [40:19] TRACE Finish step
23 May 2018 22:48:41 [40:null] TRACE Finith modulation
23 May 2018 22:48:41 [40:null] TRACE Show statistics
23 May 2018 22:48:41 [40:null] INFO People status results: '[3,3]'
23 May 2018 22:48:41 [40:null] INFO People waiting results: '[1,1]'
\end{lstlisting}

	С помощью приведённой чисти журнал, можно собрать некоторую статистику о проделанной работе. Например,
		по результатам показанной части журнала можно сделать вывод, что все пассажиры доставлены
		и ожидание каждого их них не составило дольше одной единицы времени. 

	В приложении Б при ведён журнал, вмещающий в себя информацию о деталях работы моделируемого процесса от запуска
		до завершения.

	\subsection{Блок управления на языке Prolog}

		Вот время работы кабины имеют график, в котором отражено какие этажи будут посещены донной кабиной.
			Таким образом каждая камина обладает списком задач, который необходимо выполнить. Если этот
			список пустует, то кабина находится в покое.
			В момент поступления запроса система управления должна принять решение, в чью очередь задач
			должен попасть этаж, с которого поступил запрос. То есть система должна вычислить какая кабина
			ближе к этажу, откуда поступил запрос, с учётом очереди задач кабины.

		Ниже приведена часть программы, которая отвечает за поиск наиболее подходящей кабины:
\begin{lstlisting}
get_dist(Pos, [], Floor, Res) :- Res is abs(Pos - Floor).
get_dist(Pos, [H | T], Floor, Res) :-
	(H = -1 ->
		get_dist(Pos, T, Floor, Dist),
		Res is Dist + 1
	;
		get_dist(H, T, Floor, Dist),
		Res is Dist + abs(Pos - H)
	).

fill_dist(0, _, Dist, Dist).
fill_dist(Ind, Floor, Dist, Res) :-
	NextInd is Ind - 1,
	var_getvalue(elevators_floors, ElevFloors),
	get_elem(ElevFloors, NextInd, 0, ElevPos),
	atom_concat('elev_rmap_', NextInd, MapName),
	term_string(MapTerm, MapName),
	var_getvalue(MapTerm, Map),
	get_dist(ElevPos, Map, Floor, D),
	set_elem(Dist, NextInd, 0, D, NewDist),
	fill_dist(NextInd, Floor, NewDist, Res).

find_available_elev(Floor) :-
	nb_getval(n_elevators, NElev),
	zero_list(NElev, Dist),
	fill_dist(NElev, Floor, Dist, Distances),
	swritef(ElevDistLog, 'Current distances are \'%t\'', [Distances]),
	logdebug(ElevDistLog),
	get_min_dist_id(Distances, MinDist, Elev),
	swritef(ElevMinDistLog, 'Current min dist \'%t\' with id \'%t\'', [MinDist, Elev]),
	logdebug(ElevMinDistLog),
	append2map(Elev, Floor).

find_in_list([], _, Res) :- Res = false.
find_in_list([H | T], Val, Res) :-
	(H = Val ->
		Res = true
	;
		find_in_list(T, Val, Res)
	).

find_in_elev_lists(_, Ind, Res) :- Ind =< 0, Res = false.
find_in_elev_lists(Floor, Ind, Res) :-
	Ind >= 0,
	NextInd is Ind - 1,
	atom_concat('elev_rmap_', NextInd, ListName),
	term_string(ListTerm, ListName),
	var_getvalue(ListTerm, List),
	find_in_list(List, Floor, FRes),
	(FRes ->
		Res = true
	;
		find_in_elev_lists(Floor, NextInd, Res)
	).

find_floor(Floor, Res) :-
	nb_getval(n_elevators, NElev),
	find_in_elev_lists(Floor, NElev, Res).

elev_call(Floor) :-
	find_floor(Floor, IsFloorInMaps),
	(IsFloorInMaps ->
		logdebug('Floor is in maps')
	;
		logtrace('Putting floor to map'),
		find_available_elev(Floor)
	).
\end{lstlisting}

	Представленный выше код от иллюстрирует алгоритм, по которому происходит поиск решения.
		Данная реализация является более развитой, чем реализация представленная на языке Python,
		но всё равно поиск производится по достаточно простому принципу.

	\subsection{Интеллектуальная реализация на языке Prolog}

		Как уже было замечено, при поступлении запроса система управления имеет целый перечень вариантов решения.
			И почти каждое решение влечёт за собой различные варианты развития событий. Возможны даже
			ситуации, когда с очки зрения уже про иллюстрированного подхода вариант решения является не подходящем,
			это решение может оказать самым наилучшим ввиду меняющихся условий с течением времени.

		В приложении А размещён код, который иллюстрирует реализацию формулы реализующей следующие функции:
		\begin{itemize}
			\item[--] обход возможных вариантов будущего;
			\item[--] сбор статистики с каждого варианта;
			\item[--] выбор наиболее подходящего варианта будущего по признаку.
		\end{itemize}

			В данном случае интересующим признаком является среднее ожидание человеком кабины. 
				За время поиска наиболее подходящего варианта решения, про исходит обход дерева
				возможных состояний системы, рассмотрев варианты и произведя оценку система выбирает более
				более подходящую кабину. Часть приведённая ниже ниже как раз демонстрирует  этот выбор.
\begin{lstlisting}
do_simulate(Floor, Elev, H) :-
	nb_getval(current_sim, SimPrefix),
	append2map(Elev, Floor),
	manage_elevators,
	var_getvalue(step, Step),
	Next is Step + 1,
	var_setvalue(step, Next),
	simulate_loop(SimPrefix),
	sim_getval(SimPrefix, people_waiting, PeopleWaitingList),
	sum_list(PeopleWaitingList, H),
	swritef(SimLog, 'Waiting sum is \'%t\'', [H]),
	logdebug(SimLog).
simulate(Floor, Elev, H) :-
	(nb_current(current_sim, CurrentPrefix) ->
		atom_concat(CurrentPrefix, Elev, SimPrefix),
		atom_concat(SimPrefix, '_', Prefix),
		init_sim(Prefix),
		nb_setval(current_sim, Prefix),
		do_simulate(Floor, Elev, H),
		nb_setval(current_sim, CurrentPrefix)
	;
		atom_concat('r_', Elev, SimPrefix),
		atom_concat(SimPrefix, '_', Prefix),
		init_sim(Prefix),
		nb_setval(current_sim, Prefix),
		do_simulate(Floor, Elev, H),
		nb_delete(current_sim)
	).
\end{lstlisting}

	Таким образом данная система является более интеллектуально в сравнении с предыдущем вариантом.

	\subsection{Ведение журнала для интеллектуальной реализации}
		Учитывая тот факт что поиск решения усложнился, следует полагать, что возросла потребность
			в более информативных записях в журнале. Для записей из такого журнала
			нужно добавить информацию как проходил обход имеющихся решений.

		Изучив изложенный приложении Б журнал, можно увидеть, что происходит построение дерева формулы и её обход.
			Для того чтобы было нагляднее следует прокомментировать строку лога.

\begin{lstlisting}
with elev.cab.request() as request:
24 May 2018 06:49:49 [71:2] [r_0_:4] TRACE Start step
24 May 2018 06:49:49 [71:2] [r_0_:4] TRACE Do loop step
\end{lstlisting}

		Первые четыре столбца в логе - это реальное время журналирования момента модуляции.
			Следующим столбцом идёт связка двух чисел, первое число - это номер процесса,
			он необходим для идентификации сессии, а второе число показывает момент времени модуляции.
			Ещё одним столбцом является связка строки и числа, число - это так же момент времени в данной ветки формулы,
			А строка отражает индекс чанка формулы в момент вывода, r означает корень выводимой формулы,
			а дальше серез нижние подчёркивание перечислены индексы кабин, которые участвуют
			в логическом выводе в данные момент.

		Так же следует упомянуть, что отдельное внимание требует инициализация обработки одного из решений:

\begin{lstlisting}
24 May 2018 06:49:49 [71:2] TRACE Copy var 'step' into 'r_0_step' with val '2'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'people_targets' into 'r_0_people_targets' with val '[4,4]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'people_floors' into 'r_0_people_floors' with val '[1,0]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'people_waiting' into 'r_0_people_waiting' with val '[0,0]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'people_states' into 'r_0_people_states' with val '[1,0]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'elevators_floors' into 'r_0_elevators_floors' with val '[0,1]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'elev_rmap_1' into 'r_0_elev_rmap_1' with val '[]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'elev_people_1' into 'r_0_elev_people_1' with val '[]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'elev_rmap_0' into 'r_0_elev_rmap_0' with val '[]'
24 May 2018 06:49:49 [71:2] TRACE Copy var 'elev_people_0' into 'r_0_elev_people_0' with val '[]'
\end{lstlisting}

		Рассмотрев от журнал можно сделать вывод, что при инициализации рассмотрения варианта решения
			происходит копирование переменных окружения. Это необходимо для того, что бы 
			основные данные при моделировании небыли испорчены.

	\subsection{Реализация на языке Prolog с элементом вероятности}
		Очевидно, что очень сильно упрощена. Более того в реальной жизни не всегда известно
			в какое время ожидать запрос на обработку.

		Добавление правила, приближающую текущую реализацию к реальной жизни, подчеркнёт
			гибкость разработанного программного продукта. И это докажет что данная система легко настраиваемая
			под разного рода задачи.

		С помощью пары правил добавляется элемент вероятности к появлению запроса:
\begin{lstlisting}
(nb_current(current_sim, _) -> TheVer = Prob ; TheVer = Ver),
(TheVer >= 50 ->
	get_people_elem(people_floors, Id, Floor),
	swritef(AppearLog, 'A man appears with id \'%t\' on floor with id \'%t\'', [Id, Floor]),
	loginfo(AppearLog),
	set_people_elem(people_states, Id, 1),
	elev_call(Floor)
;
	set_people_elem(people_states, Id, -1),
	loginfo('A man does not appear')
)
\end{lstlisting}

		Такие изменения повлекут за собой ложные запросы, которые будут рассмотрены системой управления.

		Получив такой вариант программы, можно сделать вывод, что данная реализация легко  может быть адаптирована
			под любую систему или среду.

	\subsection{Добавление ограничений на логический вывод}
		В ходе выполнения тестирования обнаружился интересный факте, более интеллектуальные реализации
			прекращали работу до её завершения из-за недостатка ресурсов. 

		Естественно, вопрос заключается в том, что когда программа проходит возможные варианты,
			программное решение выполняет слишком много операций.

		В данном случае решением является правило ограничивающие то, на сколько много последовательных запросов
			в будущем система должна учитывать.
\begin{lstlisting}
simulate_loop(SimPrefix) :- nb_getval(deep, Deep), string_length(SimPrefix, CurrentDeep), Deep =< CurrentDeep.
simulate_loop(SimPrefix) :-
	nb_setval(current_sim, SimPrefix),
	sim_getval(SimPrefix, step, Step),
	nb_getval(n_steps, Steps),
	Step >= Steps,
	swritef(SimLog, 'Simulation \'%t\' is finished', [SimPrefix]),
	logtrace(SimLog),
	show_stat.
simulate_loop(SimPrefix) :-
	nb_setval(current_sim, SimPrefix),
	var_getvalue(step, Step),
	nb_getval(n_steps, Steps),
	Step < Steps,
	logtrace('Start step'),
	simulate_loop_step,
	logtrace('Finish step'),
	Next is Step + 1,
	var_setvalue(step, Next),
	simulate_loop(SimPrefix).
\end{lstlisting}
		
		 После такой реализации более интеллектуальное решение стало чаще ошибаться. В результате имеется два варианта:
		 	иметь дорогое высокопроизводительное оборудование или пользоваться менее интеллектуальной программой.
