\section{Реализация программного решения}

	Для реализации поставленной цели была необходимость в решении двух задач:
		\begin{itemize}
			\item[--] реализация среды, в которой должна происходить работа системы управления;
			\item[--] реализация системы, которая должна посредством доказательства теоремы выполнять
				управление группой лифтов, тем самым обслуживая поступаемые в течении времени запросы.
		\end{itemize}

	Выполнение обоих задач на языке высокого уровня было бы не корректно,
		так как подобные языки не являются декларативными,
		что делает наделение системы управления интеллектуальностью значительно усложняет задачу.
		Но и реализация среды на языке Prolog является не совсем удачно идеей,
		так как это увеличит количество потребляемых ресурсов.
		Однако реализовывать эти задачи на разных языках, а потом настроить совместную работу тих решений,
		является непростой задачей, которая займёт достаточно много времени.
		Поэтому было принято решение обе задачи реализовать на языке Prolog, так как основной
		целью работы является разработка интеллектуальной системы управления.
		Более того, правила для описания среди можно использовать в построении логического вывода.

	В процессе работы поставленные задачи были решены разными способами:
		\begin{itemize}
			\item[--] реализация на языке Python;
			\item[--] реализация но языке Prolog.
		\end{itemize}
	
	Хоть и целесообразность использования языка Prolog понятна, реализация на Python будет необходима для сравнения
	обоих решений. А сам язык Python достаточно прост и обладает большим количеством решений для моделирования
	различных сред, в данном случае используемым решением является библиотека SimPy.

	\subsection{Описание реализации на SimPy}

		Данная реализация системы управления группой лифтов с ограниченным количеством кабин и несколькими людьми,
			которые приходят для попадания с одного этажа на другой.
			В данной системе используется ресурс для моделирования ограниченного количества кабин.
			Он также определяет процесс выбора кабины и перевозку ей человека.

		Когда человек появляется рядом с шахтой лифта, он вызывает первую из свободных кабин.
			Как только он его кабина забирает, время ожидания человека прекращается.
			Он, наконец, добирается до нужного этажа и уходит.

		После старта системы начинается генерация людей, они появляются после случайного интервала времени,
		пока продолжается симуляция.


		При том, что данная программа является многопоточной, стоит отметить тот факт, что здесь используются общие ресурсы.
			Эти ресурсы могут использоваться для ограничения количества процессов, использующих их одновременно.
			Процесс должен запрашивать право использования ресурса. Как только право на использование больше не требуется,
			оно должно быть выпущено. Данная система смоделирована как ресурс с ограниченным количеством кабин.
			Люди прибывают к кнопке вызова кабины и просят выполнить перевозку на другой этаж.
			Если все кабины заняты, человек должен ждать, пока один из пассажиров не закончит поездку и не освободит кабину.

		Данная реализация получилась достаточно простой, весь исполняемый скрипт поместился в один файл.
			Листинг того файла размещён в приложении А. Из листинга видно, как с помощью библиотеки SimPy
			было выполнено управление общими ресурсами (кабинами). Это выполнялось при помощи функции Resourse.
			Так же можно заметить как выполнялся запрос на резервирование общих ресурсов:
\begin{lstlisting}
with elev.cab.request() as request:
	yield request
	info('%s is moving' % (man.name), env)
	yield env.process(elev.moving(man))
\end{lstlisting}

		Таким образом было реализовано и ожидание ресурса, если тот на время появления запроса занят.

	\subsection{Ведение журнала о выполнении программы}
		Так как разрабатываемые реализации не обладают графическим интерфейсом, очень важно обратить внимание
			на разработку журнала программы. Посредством разработанных журналов можно детально изучить
			особенности выполнения программных решений и сделать выводы о корректности работы.

		Информация в журнале разделяется на следующие типы:
			\begin{itemize}
				\item[--] INFO -- некоторая информация о ходе выполнения или некоторые оповещения;
				\item[--] TRACE -- трассировка программы, позволяет отследить, через какие состояния прошла программа;
				\item[--] DEBUG -- подробная информация о протекающих процессах, данная информация достаточно объемная,
					поэтому подобная информация выводилась только при отладке программ;
				\item[--] WARNING -- важные предупреждения, которые помогают выявить критичные участки кода,
					которые могут вести к некорректной работе;
				\item[--] ERROR -- информация о критичных ошибках в выполнении программы. Эта информация помогает
					быстро исправлять ошибки в коде.
			\end{itemize}

		Так же реализована возможность задавать уровень ведения журнала, которая позволяет не захламлять журнал,
			если нет необходимости в подробной информации. Например, для иллюстрации журнала в отчётах
			отладочная информация не нужна, или для проведения тестов достаточно получать предупреждения
			и информацию о результатах проведения теста.

		В процессе разработки ведения журнала было выделено четыре уровня:
			\begin{itemize}
				\item[--] вывод только предупреждений и информации об ошибках;
				\item[--] предупреждения, ошибки и оповещения;
				\item[--] предупреждения, ошибки, оповещения и трассировка;
				\item[--] предупреждения, ошибки, оповещения, трассировка и отладочная информация;
			\end{itemize}

		Сама же запись в журнал имеет следующую структуру.
		Первые четыре столбца в журнале -- это реальное время журналирования момента модуляции.
		Следующим столбцом идёт связка двух чисел, первое число - это номер процесса,
		он необходим для идентификации сессии, а второе число показывает момент времени модуляции.
		А дальнейшая информация передаёт сообщения записываемые программой.

	\subsection{Пример работы реализации на SimPy}

		Данный пример иллюстрирует работу группы лифтов, где их количество равно 2, в здании с 30 этажами.
			В ходе работы системы появится люди в случайные моменты времени на случайных этажах этажах,
			и у каждого человека целью является добраться на другой этаж.

		Изначально первая кабина находится на первом этаже $e_0$, а вторя на втором $e_1$.
			Ниже приведён лог показывающий работу системы:

\begin{lstlisting}
19 May 2018 16:00:58 [51:null] Session end
23 May 2018 21:41:15 [23:null] Start session
23 May 2018 21:41:15 [23:0] Man 0 appears on floor '0', target '24'
23 May 2018 21:41:15 [23:0] Man 0 is moving
23 May 2018 21:41:15 [23:12] Man 1 appears on floor '14', target '5'
23 May 2018 21:41:15 [23:12] Man 1 is moving
23 May 2018 21:41:15 [23:24] Man 0 has reached by Cab 0
23 May 2018 21:41:15 [23:24] Man 2 appears on floor '2', target '10'
23 May 2018 21:41:15 [23:24] Man 2 is moving
23 May 2018 21:41:15 [23:33] Man 3 appears on floor '3', target '1'
23 May 2018 21:41:15 [23:34] Man 2 has reached by Cab 0
23 May 2018 21:41:15 [23:34] Man 3 is moving
23 May 2018 21:41:15 [23:35] Man 1 has reached by Cab 1
23 May 2018 21:41:15 [23:39] Man 3 has reached by Cab 0
23 May 2018 21:41:15 [23:null] Session end
9 May 2018 16:00:58 [51:null] Session end
\end{lstlisting}

			Изучив выше изложенный журнал, можно увидеть, что за время симуляции появилось 4 человека,
				каждый человек доставлен.

		\subsection{Интеллектуальная реализация на языке Prolog}

		Однако, пусть реализация логического вывода на языке Prolog является целесообразной задачей, но для разделения моделируемой системы на логический блок и блок взаимодействия объектов необходима клиент-сервергая связка. А реализация сервера или клиента на языке Prolog не является его типовой задачей, что и касается реализации графической составляющей системы моделирования.

			Таким образом более целесообразном будет оставить блок взаимодействия объектов реализованными на языку Prolog.
				Более того, правила описанные для модуляции системы будут использованы
				для построения решения логическим блоком.

			Данный код иллюстрирует реализацию формулы реализующие обход возможных вариантов будущего, сбор статистики с каждого варианта и выбор наиболее подходящего варианта будущего по признаку. в данном случае интересующим признаком является среднее ожидание человеком кабины. 

% \input{src/pl_mod_code.tex}

	Благодаря функционалу SWI-Prolog
		предикаты отражающие состояние системы в момент вызова кабины можно будет указывать в правилах только при необходимости.

		\subsubsection{Пример работы реализации}

	Данный пример иллюстрирует работу группы лифтов, где их количество равно 2, в здании с 5 этажами.
		В ходе работы системы появится два человека в моменты времени $t_2$ и $t_4$ на этажах $e_1$ и $e_0$,
		и у каждого человека целью будет четвёртый этаж $d_4$.

	Изначально первая кабина находится на первом этаже $e_0$, а вторя на втором $e_1$.
		Ниже приведён лог показывающий работу системы:

		%example

Изучив выше изложенный журнал, можно увидеть, что происходит построение дерева формулы и её обход.
	Для того чтобы было нагляднее следует прокомментировать строку лога.

Первые четыре столбца в логе - это реальное время журналирования момента модуляции.
	Следующим столбцом идёт связка двух чисел, первое число - это номер процесса,
	он необходим для идентификации сессии, а второе число показывает момент времени модуляции.
	Ещё одним столбцом является связка строки и числа, число - это так же момент времени в данной ветки формулы,
	А строка отражает индекс чанка формулы в момент вывода, r означает корень выводимой формулы, а дальше серез нижние подчёркивание перечислены индексы кабин, которые участвуют в логическом выводе в данные момент.

		
		% Ниже представлен основной файл, в котором реализован инициализация логического вывода.
		% Данный код иллюстрирует реализацию формулы времени. Благодаря функционалу SWI-Prolog
		% в дальнейшем предикаты отражающие время можно будет указывать в правилах только при необходимости.

	% Реализации правил manage\_people и manage\_elevators вынесены в другие файлы,
	%     как как являются весьма громоздкими.
	%     Manage\_people отвечает за внешний фактор (случайное появление нуждающихся в лифте людей).
	%     А manage\_elevators включает в себя формулы движения лифтов.

	% \subsection{Пример работы реализации}
    %
	% Данный пример иллюстрирует работу группы лифтов, где их количество равно 2, в здании с 5 этажами.
	%     В ходе работы системы появится два человека в моменты времени $t_2$ и $t_4$ на этажах $e_1$ и $e_0$,
	%     и у каждого человека целью будет четвёртый этаж $d_4$.
    %
	% Изначально первая кабина находится на первом этаже $e_0$, а вторя на втором $e_1$.
	%     Ниже приведён лог показывающий работу системы:
    %
	% Изучив выше изложенный журнал, можно увидеть результат, что каждый человек доставлен и ожидание составило не более одной единицы времени.
