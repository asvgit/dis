\section{Используемые технологии}

	Логическое исчисление состоит из трёх компонент: язык, аксиомы и правила вывода.
    
Позитивно--образованные формулы (ПОФ)

Пусть, $X$ --- множество переменных, и $A$ --- конъюнкт.
\begin{itemize}

\item[--]$\exists_XA$ и $\forall_XA$ есть $\exists$--ПОФ и $\forall$--ПОФ соответственно;

\item[--] Если $F = \{F_1,\ldots,F_n\}$ есть $\forall$--ПОФы, тогда $\exists_XA\colon F$ есть $\exists$--ПОФ;

\item[--] Если $F = \{F_1,\ldots,F_n\}$ есть $\exists$--ПОФы, тогда $\forall_XA\colon F$ есть $\forall$--ПОФ;

\item[--] Любая $\exists$--ПОФ или $\forall$--ПОФ есть ПОФ.

\end{itemize}


Данный вид формул называется позитивно-образованным, поскольку для их записи используются только позитивные типовые кванторы. Иными словами, формула не содержит оператора отрицания.

Любая формула языка предикатов первого порядка может быть представлена как позитивно--образованная формула. Таким образом ПО--формула есть особый вид записи классических формул языка предикатов, подобно КНФ, ДНФ и др.

ПО--формула начинающаяся с $\forall \emptyset$ называется ПО--формулой в {\em каноническом виде}.

Очевидно, что любая ПОФ может быть приведена к каноническому виду. Действительно, допустим $F$ --- это $\exists$--ПОФ, тогда выражние вида $\forall \emptyset\colon F$ по определению является $\forall$--ПОФ, и соответствует записи $true \rightarrow F$ тождественной $F$. Если $F$ --- это неканоническая $\forall$--ПОФ, тогда $\forall \emptyset\colon\{\exists \emptyset\colon F\}$ соответствует записи $true \rightarrow \{true\&F\}$, тождественной $F$. Типовые кванторы $\forall \emptyset$ и $\exists \emptyset$ называются {\em фиктивными}, поскольку не влияют на истинность формулы и не связывают никаких переменных, а только лишь служат конструкциями сохраняющими корректную запись ПОФ.

Для удобства читаемости формул, будем представлять их в древовидной форме следующим образом:
$$Q_XA\colon\{F_1,\ldots,F_n\} \equiv Q_XA \left\{
\begin{array}{lcl}
 F_1 \\
 \ldots \\
 F_n
\end{array}
\right.,$$

\noindent{}где $Q$ некоторый квантор, и пользоваться соответствующей терминологией: узел, корень, лист, ветвь и т.д. Учитывая что квантору $\forall$ соответствует дизъюнкция формул $\{F_1,\ldots,F_n\}$, а квантору $\exists$ соответствует конъюнкция, то будем говорить что $\forall$ узлу соответствует {\em дизъюнктивное ветвление}, а $\exists$ узлу {\em конъюнктивное}.

Некоторые части канонической ПО--формулы имееют специальные названия:
\begin{itemize}
\item[--] Корневой узел имеет вид $\forall \emptyset$ и назвается {\em корень ПО--формулы};

\item[--] Дочерние узлы корня ПО--формулы имеют вид $\exists_XA$ и называются {\em базами ПО--формулы}, конъюнкт $A$ называется {\em базой фактов}, а вся подформула начинающаяся с базового узла называется {\em базовой подформулой};

\item[--] Дочерние узлы баз имею вид $\forall_YB$ и называются {\em вопросами} к родительской базе. Если вопрос является листовым узлом $\forall_YB \equiv \forall_YB\colon false$, то он называется {\em целевым вопросом}. %Иногда, для того чтоб подчеркнуть тот факт что вопрос является целевым, будем в явной форме записывать конcтанту $false$.

\item[--] Поддеревья вопросов называются {\em консеквентами} или {\em следствиями}. Следствием целевого вопроса является $false$.

\end{itemize}


На примере аналогии с языком Пролог можно более доступно рассмотреть ПО-формулы.

\begin{itemize}
\item[--] База фактов ПОФ, являющаяся конъюнкцией атомов, соответствует множеству фактов пролога.
\item[--] Правила пролога имеют форму \texttt{P0:- P1,..., Pn}. В данном случае, \texttt{P1,...,Pn} соответствует конъюнкту вопроса, а \texttt{P0} его консеквенту (следствию). Отметим, что язык ПО--формул несколько богаче чем язык пролога, поскольку допускает использование в качестве консеквента дизъюнкцию произвольных формул, пролог же допускает лишь одну атомарную формулу.
\item[--] Целевой вопрос ПО--формулы вида $\forall_YB$ соответствует запросу пролога.
\end{itemize}

Рассмотрим следующую программу на языке Пролог и запрос к ней:
\texttt{\raggedright\noindent
\\
in(a,b).\\
in(b,c).\\
it(X,Y):-in(X,Z),in(Z,Y).\\
?- it(a,X).\\
}

Соответствующая данной программе ПО--формула:

$\forall \emptyset\colon\exists in(a,b),in(b,c)\colon\left\{
\begin{array}{lcl}
 \forall_{x,y,z}in(x,z),in(z,y)\colon\exists it(x,y) \\
 \forall_x it(a,x)
\end{array}
\right..$


    Исходя из вышеописанного и учитывая удобство адаптации языка к ПО-формулам для реализации вычисления позитивно образованных формул подошёл декларативный язык программирования общего назначения Prolog. При помощи этого языка,можно реализовать рассмотрение множества вариантов обхода дерева формулы.
	
	\subsection{SWI-Prolog}
		Prolog (Programming in logic) -- один из старейших и все еще один из наиболее популярных языков логического программирования,
			хотя он значительно менее популярен, чем основные императивные языки. Это язык высокого уровня, не алгоритмический, предназначенный для написания программ с использованием концепций и методов логического программирования. В основе Пролога лежит раздел математической логики, называемый исчисление предикатов. Его базис составляет процедура доказательства теорем методом резолюции для хорновских дизъюнктов. Пролог включает механизм вывода, который основан на сопоставлении образцов, с помощью подбора ответов на запросы он извлекает хранящуюся (известную) информацию.
            
Области применения языка Prolog и декларативных языков в целом

\begin{itemize}
   \item[--] Реализация систем искусственного интеллекта
   \item[--] Создание экспертных систем и оболочек экспертных систем
   \item[--] Разработка систем помощи принятия решений
   \item[--] Разработка систем обработки естественного языка
   \item[--] Построение планов действий роботов и т.п.
\end{itemize}

Особенности языка

\begin{itemize}
    \item[--] Описание проблемы и правил ее решения
    \item[--] Нахождение всех возможных решений с помощью механизма поиска с возвратом (backtracking)
    \item[--] Легкий синтаксис
\end{itemize}
	
		Prolog был создан под влиянием более раннего языка Planner и позаимствовал из него следующие идеи:

		\begin{itemize}
			\item[--] обратный логический вывод (вызов процедур по шаблону, исходя из целей);
			\item[--] построение структура управляющей логики в виде вычислений с откатами;
			\item[--] принцип “отрицание как неудача”;
			\item[--] использование разных имен для разных сущностей.
		\end{itemize}

		Главной парадигмой, реализованной в языке Prolog, является логическое программирование.
			Как и для большинства старых языков, более поздние реализации, например, Visual Prolog,
			добавляют в язык более поздние парадигмы, например, объектно-ориентированное или управляемое
			событиями программирование, иногда даже с элементами императивного стиля.

		Prolog использует один тип данных, терм, который бывает нескольких типов:

		\begin{itemize}
			\item[--] атом — имя без особого смысла, используемое для построения составных термов;
			\item[--] числа и строки такие же, как и в других языках;
			\item[--] переменная обозначается именем, начинающимся с прописной буквы,
				и используется как символ-заполнитель для любого другого терма;
			\item[--] составной терм состоит из атома-функтора, за которым следует несколько аргументов,
				каждый из которых в свою очередь является атомом.
		\end{itemize}

		Программы, написанные на чистом Prolog, описывают отношения между обрабатываемыми сущностями при помощи клауз Хорна. Клауза — это формула вида Голова :- Тело., которая читается как “чтобы доказать/решить Голову, следует доказать/решить Тело”. Тело клаузы состоит из нескольких предикатов (целей клаузы), скомбинированных с помощью конъюнкции и дизъюнкции. Клаузы с пустым телом называются фактами и эквивалентны клаузам вида Голова :- true. (true — не атом, как в других языках, а встроенный предикат).

		Другой важной частью Prolog являются предикаты. Унарные предикаты выражают свойства их аргументов, тогда как предикаты с несколькими аргументами выражают отношения между ними. Ряд встроенных предикатов языка выполняют ту же роль, что и функции в других языках

		В качестве реализации языка Prolog был выбран SWI-Prolog.
			В данной реализации имеется необходимы функционал, а именно предикаты nb\_getval, nb\_setval и nb\_current.
			Эти предикаты позволяют использовать другие предикаты в качестве глобальных переменных, что
			позволяет существенно упростить написание правил для вычисления.

		SWI-Prolog — это свободная (открытая) реализация языка программирования \\ Prolog, часто используемая для преподавания и приложений Semantic Web. Эта реализация представляет богатый набор возможностей, библиотеки для constraint logic programming, многопоточности, юнит-тестирования, интерфейс к языку программирования Java, ODBC и т. д., поддерживает литературное программирование, содержит реализацию веб-сервера, библиотеки для SGML, RDF, RDFS. 
        
        Ниже приведены некоторые особенности юиблиотеки SWI-Prolog:
       
\begin{itemize}
   \item[--]   является мощной средой разработки с набором графических инструментов ХРСЕ. Ядро системы лицензировано под GNU LGPL, библиотеки — под GNU GPL с дополнительным условием, позволяющим использование в проприетарных приложениях. 

    \item[--] система довольно популярна, в основном благодаря удобной среде и переносимой библиотеке для создания графического интерфейса. SWI-Prolog, как почти все реализации языка, по большей части реализует Edinburgh Prolog, но также содержит отдельные элементы ISO Prolog.

    \item[--] SWI-Prolog включает в себя быстрый компилятор, профилировщик, набор библиотек и удобный интерфейс для подключения C-модулей. Он реализован для ряда UNIX-платформ, таких, как HP, IBM Linux, для NeXT, OS/2, Sun и Sparc.
\end{itemize}

\subsection{SimPy}

	Так же было разработано программное решение на языке python с использование фреймворка SimPy.
		Который позволил за короткий срок на реализовать программное решение для проведения различных тестов.  

	SimPy - это Python фреймворк процессо-ориентированной дискретно-событийной системы моделирования. Его диспетчеры событий основаны на функциях-генераторах Python.

	Также они могут использоваться для создания асинхронных сетей или для реализации мультиагентных систем (с как моделируемым, так и реальным взаимодействием).

	Процессы в SimPy - это просто Python генераторы, которые используются для моделирования активных компонентов, например, таких как покупатели, транспортные средства или агенты. SymPy также обеспечивает различные виды общих ресурсов для моделирования точек с ограниченной пропускной способностью (например, серверов, касс, тоннелей). Начиная с версии 3.1, SimPy также будет обеспечить возможности мониторинга для помощи в сборе статистических данных о ресурсах и процессах. 

	SymPy представляет собой открытую библиотеку символьных вычислений на языке Python. Цель SymPy - стать полнофункциональной системой компьютерной алгебры (CAS), при этом сохраняя код максимально понятным и легко расширяемым. SymPy полностью написан на Python и не требует сторонних библиотек.

	SymPy можно использовать не только как модуль, но и как отдельную программу. Программа удобна для экспериментов или для обучения. Она использует стандартный терминал IPython, но с уже включенными в нее важными модулями SymPy и определенными переменными.

	\subsection{Дополнительный инструментарий}

		В процессе реализации было создано порядка десяти файлов с описанием правил логического вывода
			общей суммой порядка тысячи строк. Такое большое количество правил обусловлено наличием деталей и нюансов.

		Как и в любом развивающемся программном решении возникает потребность вести учёт версий данного
			программного решения. Для тих целей использовалась система контроля версий Git.
			Что позволило не только вести учёт версий программной реализации,
			но и размещать разрабатываемые материалы на публичном репозитории.

		В качестве среды разработки использовался Vim. Данный инструмент позволяет адаптировать его
			под любой язык программирования, так же в свободном доступе имеются расширения для Prolog,
			Python, Git и так далее.
